# Chapter 1: What is Scope?

「变量」是几乎所有编程语言的基础。但是这些变量是存储在什么地方？更重要的是怎么样找到这些变量？这就涉及到一系列存储和查找变量的「规则」，也就是我们说的「作用域」。但是，这些「作用域规则」是在哪里，怎么样被指定的？

## Compiler Theory

JavaScript 事实上是一种 「compiled language」，但跟传统的编译型语言不同，JavaScript不会在构建阶段提前编译，而是仅仅在执行之前几微秒（可能更少）才编译，所以 JavaScript 引擎也不会有大量的时间来优化代码。
一般来说，编译过程都会包括三个步骤：

1. **Tokenizing/Lexing**：把由字母组成的字符串截断成对于编程语言来说有意义的「chunks」，或者说「tokens」。例如，把`var a = 2`截断成以下 tokens ：`var`, `a`, `=`, `2`, 和 `;`。
2. **Parsing**：把上一步得到的字符流转换成「AST」。
3. **Code-Generation**：根据上一步中得到的 AST ，生产可执行的代码。

JavaScript 引擎除了会执行以上的编译步骤，还会执行代码优化、去除冗余等步骤。

## Understanding Scope

以`var a = 2;`这一段小程序来做例子。

从人的角度来看，一般会把这段程序看做一个 statement，但是 JavaScript 引擎会把它分成两个 statement：`var a`和`a = 2`，第一个 statement 会由*编译器*在编译*阶段*处理，第二个 statement 会由*引擎*在*执行*阶段处理。

- 对于第一个 statement，编译器会执行上述三个编译步骤的前两个。在执行第三个步骤之前，编译器会先在当前作用域里查找是否有这个变量`a`。如果有，就不会再声明这个变量`a`；否则，就会在当前作用域中声明一个新的变量`a`。
- 接着由引擎来处理`a = 2`。首先还是会在当前作用域中查找变量`a`，如果有，就赋值；如果没有，就到上一层作用域中查找。

对一个变量的查找，可以分成两种目的：「对变量赋值」和「检索该变量的值」。在这里，我们把第一种目的称作「LHS」，left-hand-side 查找，第二种称作「RHS」，right-hand-side。

## Nested Scope

作用域可以像函数一样嵌套。

上面说过，引擎在查找一个变量的时候，会先在当前作用域中查找。如果没有找到，就会一层一层的往外找，直到找到了对应的变量。如果到达了最外层作用域( global )不管有没有找到，都会停止查找。

## Errors

上面提到对变量的查找会有两种：LHS，RHS。之所以有这两个概念的区分是因为这两种的查找在找不到对应的变量时会导致不同的错误。

对于 RHS，也就是查找某个变量的值的时候，如果在任何嵌套的作用域中都没有找到这个变量，就会抛出一个 `ReferenceError`错误。如果找到了这个变量，但是想对这个变量的值做一下不可能的操作，例如让一个不是函数的值像函数那样执行，这时候就会抛出`TypeError`错误。

对于 LHS，也就是要对某个变量赋值时，如果没有找到这个变量，这是会有两种结果：在严格模式下，会抛出 `ReferenceError`；在非严格模式下，会隐式的创建一个全局变量，并完成赋值。

 `ReferenceError`错误是与作用域解析错误相关的；而`TypeError`错误是作用域解析成功，但尝试对结果做一些不合法/不可能的动作时产生的。