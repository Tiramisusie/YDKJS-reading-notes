# Chapter 3: Function vs. Block Scope

## Scope From Functions

函数作用域的思想是，所有属于这个函数的变量都可以在整个函数体的任何地方被使用到，无论变量是在这个函数的任何位置被定义。

## Hiding In Plain Scope

一般来说，函数都是先声明了，然后再往里面添加代码。但是反过来，把你写的任何代码都用一个函数包裹起来，也就是「隐藏」代码，同样是一种非常有用的技巧。这种方法可以把代码都「包裹」在一个独立的作用域中，使得这个函数里面的变量或者函数对外不可见，或者说「隐藏」起来。

这种方法在软件设计（例如API设计）中很有用：只把最少的、必要的东西暴露出来，供外部代码调用，而把其他代码都当做「私有」的变量保护起来。从而保证软件能正常运行。

### Collision Avoidance

「隐藏」变量或函数的另一个作用是避免同名变量或者函数之间发生冲突。

#### Global "Namespaces" 

很多第三方库都会在全局作用域里面创建一个对象，并把这个对象作为库本身的「命名空间」，所有对外暴露的变量和函数都是这个对象的属性，而不是直接暴露在全局作用域中，这样可以最大程度的避免冲突。典型的例子有 jQuery 和 underscore 。

#### Module Management

模块机制通过把类库中的变量或函数导入到特定的作用域而不是全局作用域中，从而避免变量冲突。

## Functions As Scopes

上面提到了把变量和函数「隐藏」起来，从而隔离作用域的方法。例如，

```javascript
var a = 2;
function foo() { 
  var a = 3;    
  console.log( a ); // 3
} 
foo(); 
console.log( a ); // 2
```

上面的这种技巧会有两个问题：你必须要声明一个命名的函数，例如`foo(..)`，这样`foo`这个名称就会污染周围的作用域。另外，你也必须要显式的调用这个函数。

下面的方法可以解决这两个问题：

```javascript
var a = 2;
(function foo() { 
  var a = 3;    
  console.log( a ); // 3
})();  
console.log( a ); // 2
```

`(function foo(){ .. })`是一个函数表达式，它的作用是把标识符`foo`仅仅绑定在`{..}`这个作用域中，也就是说把它隐藏起来了，避免了对外部作用域的污染。

**Note**：区分函数表达式和函数声明的最简单的方法就是看「function」关键词的位置。如果「function」在一个语句的最前面，那就是一个函数声明；否则就是一个函数表达式。

## Blocks As Scopes

### `let`

用`let`声明的变量是块级作用域。因此在开发的时候要注意每个「块」都包含了哪些变量，或者这个变量是在哪个「块」里面。为了可以更加明确哪个块里面有哪些变量，可以创建「显式的块」，其实就是在代码块外面再加一层`{..}`。如下面的例子：

```javascript
var foo = true;

if (foo) {
	{ // <-- explicit block
		let bar = foo * 2;
		bar = something( bar );
		console.log( bar );
	}
}

console.log( bar ); // ReferenceError
```

但是个人认为这样的作用不大。

在 JavaScript 的作用域中，我们有一个「变量提升」的一个概念。但是用`let`来声明的变量不会有「变量提升」的效果。

